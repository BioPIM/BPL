////////////////////////////////////////////////////////////////////////////////
// BPL, the Process In Memory library for bioinformatics 
// date  : 2026
// author: edrezen
////////////////////////////////////////////////////////////////////////////////

#include <firstinclude.hpp>

#pragma once

#include <memory>
#include <mutex>
#include <any>
#include <bpl/core/Launcher.hpp>
#include <BS_thread_pool.hpp>

////////////////////////////////////////////////////////////////////////////////
namespace bpl  {
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/** \brief Pool of Launcher objects for a given architecture.
 *
 * Such a pool is useful when one has tasks to be run asynchronously: one just submit
 * a task to the pool and the task will be executed as soon as a launcher of the pool
 * is available.
 *
 * A pool is created with a number of launchers, all the other parameters are those
 * used by the constructor of Launcher. A thread is created for each pool, so ultimately,
 * we have a pool threads in the implementation. The BS::thread_pool is used under the hood
 * for managing this pool of threads.
 *
 * \param ARCH: architecture of the Launcher objects to be created for the pool.
 */
template <class ARCH>
class LauncherPool
{
public:

    /** Architecture type of the Launcher objects. */
    using arch_t = ARCH;

    /** */
    using launcher_t = Launcher<ARCH>;

    /** Constructor. (this will delete the default constructor generated by the compiler)
     *
     * The arguments (except the first one) are used to create a configuration that will
     * be used for creating a Launcher object. By doing this, it postpones the actual
     * Launcher object creation when actually needed, in other words, the Launcher
     * objects won't be created during this constuctor call.
     *
     * \param nbLaunchers: number of launchers to be created for the pool
     * \param units: TaskUnit for a Launcher object
     */
    template<typename TUNIT, typename...ARGS>
    LauncherPool (size_t nbLaunchers, TUNIT units, ARGS&&... args)
        : nbunits_(nbLaunchers * units.getNbComponents())
    {
        // We create the thread pool as a smart pointer.
        threadpool_ = std::make_unique<BS::thread_pool<>> (nbLaunchers);

        // We get a snapshot of the configuration.
        // It will be user later when an actual launcher will be requested for the first time.
        config_ = launcher_t::make_configuration (units, std::forward<ARGS>(args)...);

        launchers_.resize (nbLaunchers);
    }

    /** Get the number of components associated to the launcher pool. This is the sum
     * of components number for all launchers.
     * \return the total number of components.
     */
    size_t getNbComponents  () const  { return nbunits_;     }

    /** Submit a task to the pool of Launcher objects.
     * \param Task: type of the task to be run
     * \param cbk: callback that will be called at the end of the execution of the task. This
     * callback takes as argument (1) the launcher that ran the task and (2) the result of the task.
     * \param args: arguments to be provided to the task as input
     */
    template<template<typename ...> class Task, typename Callback, typename...Args>
    auto submit (Callback cbk, Args&&...args)
    {
        // We need to be sure that the arguments to be used for task execution will have a life cycle long enough.
        // This is important for instance when we directly use 'split' on client side, which implies that this argument
        // is deleted as soon as the call to 'submit' is done. So we make sure here to keep the information in a 'Command'
        // function object that will be used in the 'detach_task' call.
        struct Command
        {
            LauncherPool&       parent;
            Callback            cbk;
            std::tuple<std::decay_t<Args>...> args;

            auto operator() ()
            {
                const std::optional<std::size_t> idx = BS::this_thread::get_index();

                if (idx)
                {
                    // We retrieve the launcher matching the current index
                    launcher_t& launcher = parent.getLauncher(*idx);

                    auto&& results = std::apply ([&] (auto&&... theargs)
                    {
                        // We launch the task and return its result.
                        return launcher.template run<Task> (std::forward<decltype(theargs)>(theargs)...);

                    }, args);

                    // We call the callback with the results
                    cbk (launcher, std::move(results));
                }
                else
                {
                    throw std::runtime_error ("thread pool failed to process the task");
                }
            }
        };
        threadpool_->detach_task ( Command { *this, cbk, std::make_tuple(args...) } );
    }

    /** Synchronization for the pool.
     */
    auto wait()
    {
        threadpool_->wait();
    }

    /** Number of Launcher objects in the pool
     * \return the launchers number.
     */
    size_t size() const { return launchers_.size(); }

private:

    /** The configuration to be used for creating a Launcher object. */
    std::any config_;

    size_t nbunits_     = 0;
    size_t nbProcUnits_ = 0;

    /** The vector holding the Launcher objects. */
    std::vector<std::unique_ptr<launcher_t>> launchers_;

    /** Return a Launcher given its index. It will be created at first call.
     * \param idx: index of the Launcher object
     * \return the Launcher object
     */
    launcher_t& getLauncher (size_t idx) {
        std::lock_guard<std::mutex> g (mutex_);
        // We might create the launcher if not existing
        if (launchers_[idx].get()==nullptr) {
            launchers_[idx] = launcher_t::create (config_);   }
        return *launchers_[idx];
    }

    /** Mutex needed when calling getLauncher. */
    std::mutex mutex_;

    /** The thread pool using the BS::thread_pool library. */
    std::unique_ptr<BS::thread_pool<>> threadpool_;
};

////////////////////////////////////////////////////////////////////////////////
};  // end of namespace
////////////////////////////////////////////////////////////////////////////////
